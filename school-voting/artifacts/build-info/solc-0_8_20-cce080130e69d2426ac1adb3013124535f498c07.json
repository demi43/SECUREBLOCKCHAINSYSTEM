{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-cce080130e69d2426ac1adb3013124535f498c07",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/schoolvoting.sol": "project/contracts/schoolvoting.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/schoolvoting.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/// @title Secure SchoolVoting\r\n/// @notice Time-bound election with direct and signature-authorized proxy votes (ECDSA).\r\n/// @dev This contract implements on-chain signature verification to allow server-submitted proxy votes\r\n///      only when the voter actually signed the authorization. Admin cannot prematurely end the election.\r\ncontract SchoolVoting {\r\n    /* ========== STRUCTS & STORAGE ========== */\r\n\r\n    struct Candidate {\r\n        string name;\r\n        uint256 voteCount;\r\n    }\r\n\r\n    address public owner; // admin/owner\r\n    Candidate[] public candidates;\r\n\r\n    // voter state\r\n    mapping(address => bool) public hasVoted;\r\n    mapping(address => uint256) public nonces; // for replay protection when using signatures\r\n    uint256 public voterCount;\r\n    uint256 public maxVoters;\r\n\r\n    // election timing\r\n    uint256 public electionStartTime;\r\n    uint256 public electionEndTime;\r\n    bool public electionEnded; // explicit end flag (only valid after scheduled end)\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event ElectionStarted(uint256 startTime, uint256 endTime);\r\n    event VoteCast(address indexed voter, uint256 indexed candidateIndex, uint256 timestamp);\r\n    event ElectionEnded(uint256 endedAt, address indexed endedBy);\r\n    event CandidateAdded(string name);\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDuringElection() {\r\n        require(!electionEnded, \"Election has ended\");\r\n        require(block.timestamp >= electionStartTime, \"Election not started\");\r\n        require(block.timestamp <= electionEndTime, \"Election time expired\");\r\n        _;\r\n    }\r\n\r\n    /* ========== CONSTRUCTOR / SETUP ========== */\r\n\r\n    /// @param candidateNames initial candidate names (must be unique)\r\n    /// @param _maxVoters maximum allowed voters (prevent unbounded counting)\r\n    /// @param durationHours election duration in hours\r\n    constructor(string[] memory candidateNames, uint256 _maxVoters, uint256 durationHours) {\r\n        require(candidateNames.length >= 2, \"At least two candidates\");\r\n        require(_maxVoters > 0, \"maxVoters > 0\");\r\n        require(durationHours > 0, \"duration > 0\");\r\n\r\n        owner = msg.sender;\r\n        maxVoters = _maxVoters;\r\n        electionStartTime = block.timestamp;\r\n        electionEndTime = block.timestamp + (durationHours * 1 hours);\r\n\r\n        // Add candidates and prohibit duplicate names\r\n        for (uint i = 0; i < candidateNames.length; i++) {\r\n            // basic uniqueness check (gas O(n^2) for small candidate lists is acceptable)\r\n            for (uint j = 0; j < i; j++) {\r\n                require(keccak256(bytes(candidateNames[i])) != keccak256(bytes(candidateNames[j])), \"Duplicate candidate name\");\r\n            }\r\n            candidates.push(Candidate({ name: candidateNames[i], voteCount: 0 }));\r\n            emit CandidateAdded(candidateNames[i]);\r\n        }\r\n\r\n        emit ElectionStarted(electionStartTime, electionEndTime);\r\n    }\r\n\r\n    /* ========== VIEW HELPERS ========== */\r\n\r\n    function candidateCount() external view returns (uint256) {\r\n        return candidates.length;\r\n    }\r\n\r\n    /// @notice Get the index of a candidate by exact name match\r\n    function getCandidateIndexByName(string memory candidateName) public view returns (uint256, bool) {\r\n        bytes32 target = keccak256(bytes(candidateName));\r\n        for (uint i = 0; i < candidates.length; i++) {\r\n            if (keccak256(bytes(candidates[i].name)) == target) {\r\n                return (i, true);\r\n            }\r\n        }\r\n        return (0, false);\r\n    }\r\n\r\n    /* ========== CORE VOTING FUNCTIONS ========== */\r\n\r\n    /// @notice Voter casts their own vote (transaction must be sent by voter)\r\n    function vote(uint256 candidateIndex) external onlyDuringElection {\r\n        _castVote(candidateIndex, msg.sender);\r\n    }\r\n\r\n    /// @notice Vote by candidate name (caller must be the voter)\r\n    function voteByName(string memory candidateName) external onlyDuringElection {\r\n        (uint256 idx, bool exists) = getCandidateIndexByName(candidateName);\r\n        require(exists, \"Candidate not found\");\r\n        _castVote(idx, msg.sender);\r\n    }\r\n\r\n    /// @notice Submit a vote on behalf of a voter using the voter's ECDSA signature.\r\n    /// @param candidateIndex index of the candidate\r\n    /// @param voter address of the voter (the signer)\r\n    /// @param nonce voter's current nonce at signing time (must match contract's nonces[voter])\r\n    /// @param signature 65-byte eth_sign-style signature (r,s,v)\r\n    /// @dev Message to sign is keccak256(abi.encodePacked(address(this), voter, candidateIndex, nonce))\r\n    function voteBySignature(\r\n        uint256 candidateIndex,\r\n        address voter,\r\n        uint256 nonce,\r\n        bytes calldata signature\r\n    ) external onlyDuringElection {\r\n        require(candidateIndex < candidates.length, \"Invalid candidate\");\r\n        require(!hasVoted[voter], \"Voter already voted\");\r\n        require(voterCount < maxVoters, \"Max voters reached\");\r\n\r\n        // Verify provided nonce matches current nonce for voter (prevents replay & ordered signing)\r\n        require(nonces[voter] == nonce, \"Invalid nonce\");\r\n\r\n        // Recreate message and verify signature\r\n        bytes32 digest = _prefixed(keccak256(abi.encodePacked(address(this), voter, candidateIndex, nonce)));\r\n        address recovered = _recover(digest, signature);\r\n        require(recovered == voter, \"Invalid signature\");\r\n\r\n        // consume nonce\r\n        unchecked { nonces[voter] = nonces[voter] + 1; }\r\n\r\n        // cast vote\r\n        _castVote(candidateIndex, voter);\r\n    }\r\n\r\n    /* ========== INTERNALS ========== */\r\n\r\n    function _castVote(uint256 candidateIndex, address voter) internal {\r\n        require(!hasVoted[voter], \"Already voted\");\r\n        require(candidateIndex < candidates.length, \"Candidate out of range\");\r\n        require(voterCount < maxVoters, \"Max voters reached\");\r\n\r\n        hasVoted[voter] = true;\r\n        voterCount++;\r\n        candidates[candidateIndex].voteCount++;\r\n\r\n        emit VoteCast(voter, candidateIndex, block.timestamp);\r\n    }\r\n\r\n    /* ========== ADMIN / ENDING ========== */\r\n\r\n    /// @notice End election. Only allowed after scheduled end time to prevent admin manipulations.\r\n    function endElection() external onlyOwner {\r\n        require(!electionEnded, \"Already ended\");\r\n        require(block.timestamp >= electionEndTime, \"Election still running\");\r\n        electionEnded = true;\r\n        emit ElectionEnded(block.timestamp, msg.sender);\r\n    }\r\n\r\n    /// @notice Emergency end â€” ONLY allowed if owner sets emergency flag (not implemented here).\r\n    /// Leaving this out reduces attack surface. If governance needed, add multisig/time-lock off-chain.\r\n    /// For stricter security, we intentionally disallow early admin termination in this contract.\r\n\r\n    /* ========== RESULTS & STATS ========== */\r\n\r\n    /// @notice Compute winner and whether there is a tie.\r\n    /// @return winnerName string (empty if no votes), winnerVotes, tie boolean\r\n    function getWinner() external view returns (string memory winnerName, uint256 winnerVotes, bool tie) {\r\n        // must have ended or time passed\r\n        require(electionEnded || block.timestamp > electionEndTime, \"Election ongoing\");\r\n\r\n        if (candidates.length == 0) return (\"\", 0, false);\r\n\r\n        uint256 maxVotes = 0;\r\n        uint256 winners = 0;\r\n        uint256 winnerIdx = 0;\r\n\r\n        for (uint i = 0; i < candidates.length; i++) {\r\n            uint256 v = candidates[i].voteCount;\r\n            if (v > maxVotes) {\r\n                maxVotes = v;\r\n                winners = 1;\r\n                winnerIdx = i;\r\n            } else if (v == maxVotes && v > 0) {\r\n                winners++;\r\n            }\r\n        }\r\n\r\n        if (maxVotes == 0) {\r\n            // no votes cast\r\n            return (\"\", 0, false);\r\n        }\r\n\r\n        return (candidates[winnerIdx].name, maxVotes, winners > 1);\r\n    }\r\n\r\n    function getElectionStats() external view returns (\r\n        uint256 totalVoters,\r\n        uint256 maxAllowedVoters,\r\n        uint256 remainingVoters,\r\n        bool isActive,\r\n        uint256 timeRemaining\r\n    ) {\r\n        totalVoters = voterCount;\r\n        maxAllowedVoters = maxVoters;\r\n        remainingVoters = maxVoters > voterCount ? maxVoters - voterCount : 0;\r\n        isActive = !electionEnded && block.timestamp >= electionStartTime && block.timestamp <= electionEndTime;\r\n        timeRemaining = block.timestamp < electionEndTime ? electionEndTime - block.timestamp : 0;\r\n    }\r\n\r\n    /* ========== ECDSA HELPERS (ETH_SIGN style) ========== */\r\n\r\n    /// @dev prefix according to eth_sign: \"\\x19Ethereum Signed Message:\\n32\" + hash\r\n    function _prefixed(bytes32 hash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n\r\n    /// @dev Recover signer from signature (65 bytes: r(32) | s(32) | v(1))\r\n    function _recover(bytes32 digest, bytes memory sig) internal pure returns (address) {\r\n        require(sig.length == 65, \"Invalid sig length\");\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(sig, 0x20))\r\n            s := mload(add(sig, 0x40))\r\n            v := byte(0, mload(add(sig, 0x60)))\r\n        }\r\n        // Accept both 27/28 and 0/1 signatures (some clients produce 0/1)\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        require(v == 27 || v == 28, \"Invalid v\");\r\n        address signer = ecrecover(digest, v, r, s);\r\n        require(signer != address(0), \"Invalid signer\");\r\n        return signer;\r\n    }\r\n\r\n    /* ========== ADMIN UTILS (OPTIONAL) ========== */\r\n\r\n    /// @notice Owner can add a candidate only before election starts (safer), or else the candidate list should be fixed.\r\n    function addCandidate(string memory name) external onlyOwner {\r\n        require(block.timestamp < electionStartTime, \"Can only add candidates before start\");\r\n        // basic duplicate check\r\n        for (uint i = 0; i < candidates.length; i++) {\r\n            require(keccak256(bytes(candidates[i].name)) != keccak256(bytes(name)), \"Duplicate candidate\");\r\n        }\r\n        candidates.push(Candidate({ name: name, voteCount: 0 }));\r\n        emit CandidateAdded(name);\r\n    }\r\n}\r\n"
      }
    }
  }
}